---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Talia Murray"
output: html_document
date: "2024-08-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

Workshop 1 -  Data Viz in R
Date: 26/08/2024

-------------------------------------------------------------------------------


# Install and load tidyverse packages.
```{r}
## install.packages("tidyverse") # Delete this line once installed
library("tidyverse")
```


# Load and install the data (palmerpenguins).
```{r}
# install.packages("palmerpenguins")
# install.packages("ggthemes")
library(palmerpenguins)
library(ggthemes)
palmerpenguins::penguins
penguins<- penguins
```


# Quick data checks.
```{r}
head(penguins) # Shows the top six rows of data set.
glimpse(penguins) # Shows all variables and the first few observations of each variable in the data set.
summary(penguins) # Provides information on each of the variables in the data set.

```
# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?
```{r}
ggplot() 
# Or with just the data specified?
ggplot(data = penguins)
```

If we run ggplot on its own we will just get a blank chart with no axes or information.

# Create first plot.
```{r}
ggplot(data = penguins, 
       mapping = aes(x = flipper_length_mm, y = body_mass_g)) # Mapping argument is defined using the aes() function and the x and y arguments of aes specify the variables we want to map on the x and y axes.
```

Adding the aes code will give us a blank graph with labelled axes showing where flipper length and body mass will be displayed. There is no actual data about the penguins displayed on the chart currently because there is no instructions to R about how to represent the observations from our data onto the plot.

# Add data to first plot.
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g)  #Label x and y axes.
) +
  geom_point() # Add data points to plot.

```

Now that we have specified the data told R how to represent the data it is now displayed on our chart. From this plot we could begin to answer questions that motivated our analysis for example "What does the relationship between flipper length and body mass look like?". From the chart we have created we can see that there appears to be a positive relationship that indicates that body mass will increase as flipper length increases.

The warning message provided with the chart is telling us that there are two penguins that are missing body mass and/or flipper length in our data set so R has no way of representing them on the plot.

We Want to know if this positive relationship by other variables, for example is it species dependent. To do this we can represent each species on this plot by modifying the aesthetics. 

# Change point colour by species.
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)  #Label x and y axes.
) +
  geom_point() # Add data points to plot.
```

Using the color feature in aesthetics we can select the species variable from our data set to indicate which point is representing which species. This also creates a figure legend to indicate which color corresponds to which species.

Now we want to add a relationship curve to visualise the relationship between flipper length and body mass for each species.

# Add a relationship curve:
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g, colour = species)  #Label x and y axes.
) +
  geom_point() + # Add data points to plot.
  geom_smooth(method = "lm") # Add a line of best fit.
```

Using the geom_smooth(method = 'lm') tells R we want to draw the line of best fit using a linear model. The warning is relating to the two missing points in our data.

This plot doesn't provide a line of best fit for the entire data set. If we want to correct this to have a line of best fit for the entire data set we need to specify that we only want to separate the points by species.



# Adjust line of best Fit
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g)  #Label x and y axes.
) +
  geom_point(mapping = aes(colour = species)) + # Change colour of points by species.
  geom_smooth(method = "lm") # Add line of best fit.
```

By adding aesthetics to the geom point code we are specifying that we only want to adjust the settings for points on our plot not for every layer on the plot.

To further distinguish the different species we can not only adjust the species point by color but also shape.

# Change point shape by class:
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g) #Label x and y axes.
) +
  geom_point(mapping = aes(colour = species, shape = species)) + # Change point color and shape by species type.
  geom_smooth(method = "lm") # Add line of best fit.
```

The points are now changed for each species and this is also represented in the figure legend.

We can further improve our plot aesthetics by improving our axes labels using the labs() function and changing our colour palette.

# Improve aesthetics.
```{r}
ggplot(
  data = penguins, # Specify data set.
  mapping = aes(x = flipper_length_mm, y = body_mass_g) # Label x and y axes.
) +
  geom_point(aes(colour = species, shape = species)) + # Adjust data point colour and shape.
  geom_smooth(method = "lm") + # Add a line of best fit to entire data set.
  labs(
    title = "Body mass and flipper length", # Label title.
    subtitle = "Dimensions for Adelie, Chinstrap and Gentoo Penguins", # Create a subtitle.
    x = "Flipper length (mm)", y = "Body mass (g)", # Create axes labels.
    color = "Species", shape = "Species" # Adjust legend title.
  ) +
  scale_color_colorblind() # Change color of data points by using a different color palette theme.
```



```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g) #Label x and y axes.
) +
  geom_point(mapping = aes(colour = bill_length_mm)) + # USe bill length for point color.
  geom_smooth() # Add line of best fit.
```


# Troubleshooting 


# Faceting

## facet_wrap.
```{r}
ggplot(data = penguins) + # Specify data set.
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + # Specify axes data.
  facet_wrap(~ species, nrow = 2) # This function makes a plot that represents multiple plots which we separated out by species. This now shows three plots for each species. The nrow function tells R how many rows we want on the plot.
```
This shows the relationship flipper length and body mass for each species.

## facet_grid
A separate facet for each combination of sex and species
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  facet_grid( sex ~ species)
```
This shows the relationship flipper length and body mass for each species and then further seperates this by sex of the species.


## facet_grid by just row (or column)
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  facet_grid(sex ~ .) # This tells R to just separate data into rows of each sex.
  #facet_grid(. ~ sex) # Alternatively. This will put it as columns.

```

# Exercise:

Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
?facet_wrap

# By default, the same scales are used for all panels. You can allow
# scales to vary across the panels with the `scales` argument.
# Free scales make it easier to see patterns within each panel, but
# harder to compare across panels.
ggplot(penguins, aes(body_mass_g, flipper_length_mm)) +
  geom_point() +
  facet_wrap(vars(species), scales = "free_x")

# ncol dictates the number of columns used. 
# nrow dictates the number of rows used.
# scales adjust the x and y scales. These can be fixed which is the default, or free. When using the free option we can also specify if this is specifically for the x or y axis. In the above example we made the x axis free.
# There are many other options available for the facet_wrap function depending on what your needs are. These are all accessible in the help section.
```

# Using more aesthetics in facet_wraps
```{r}
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(colour = species, shape = species)) +
  facet_wrap(~island)
```



# Lines
We already used points:
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm))
```


However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().
```{r}
ggplot(data = penguins) + 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm))
```

### Question: whey don't we use geom_line() here? What would that look like? ###
The geom line function is not really useful for the purpose of this chart. Using the smooth function we can see the trend or relationship of the data. Using the line aesthetic does not give any useful information regarding the relationship of the data.


So let’s recap. A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didn’t. 

## Using comments (#)
```{r}
ggplot(data = penguins) + 
  #geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + # Points horrible. 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm)) # Try smooth line.
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.

# Changing linetype
```{r}
ggplot(data = penguins) + 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm, linetype = species)) # Can also use linetype to specify 
```


# Grouping
```{r}
ggplot(data = penguins) +
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm, group = species))
```
 
# Change line colour based on drv value
```{r}
ggplot(data = penguins) +
  geom_smooth(
    mapping = aes(x = body_mass_g, y = flipper_length_mm, color = species),
    show.legend = FALSE,# show.legend = FALSE  tells R not to include the legend on the plot.
  )
```




# Multiple geoms

We already did this one way
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm))
```

A better way...
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point() + 
  geom_smooth()
```


# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point(mapping = aes(color = species)) + 
  geom_smooth()
```



Using the filter option we can specify a species we want to show the line of best fit for.
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point(mapping = aes(color = species)) + 
  geom_smooth(data = filter(penguins, species == "Gentoo"), se = FALSE)
```

#Question: what does the "se = FALSE" do?
se = FALSE does not include the standard error around the line. 

# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.


Run a density plot for the line chart (other times we can just use geom_line but this is not useful for this chart), run a boxplot, histogram and a bar chart.

```{r}
# Density plot:
ggplot(penguins, aes(x = body_mass_g, colour = species)) +
  geom_density(linewidth = 0.75)
#we can map species both to color and fill aesthetics and to make the fill transparent use the alpha aesthetic.
ggplot(penguins, aes(x = body_mass_g, colour = species, fill = species)) +
  geom_density(alpha = 0.5)

# Boxplot:
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()

# Histogram:
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20) # Use the binwidth argument to set the width of the intervals in the histogram, this is measured in the units of the x variable. This size is too narrow for our data.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000) # This binwidth is too large for our data.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200) # This is a better size for our binwidth.


#Bar chart:
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill") # A relative frequency plot is created by setting position = fill in the geom. This is more useful for comparing species distributions across islands since it is not affected by the unequal numbers of penguins across the islands.
```


# Mapping three or more variables
```{r}
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

In this chart we represent the island by shape and the color represents the species.

#3.  Will these two graphs look different? Why/why not?
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_smooth(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm))
```
No. It says the same thing, the second way is just a longer or more specific way of writing it.

# Transformations and stats

## Load data
```{r}
data("diamonds")
glimpse(diamonds)
```

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo
```


```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```

#Question: Why did we specify now specify a y axis?

# What if we want to know the proportion rather than the absolute frequency?
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
```

#Question: does anyone get the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.
If so, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

# Plotting statistical details
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


# Aesthetic adjustments adjustments
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

#Question: Does anyone notice anything different in the colour scheme of this plot?
(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)
Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```


# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```


# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```


# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```


# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```


# position = "dodge" 
Places overlapping objects directly beside one another.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = penguins) + 
  #geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  geom_point(mapping = aes(x = species, y = flipper_length_mm))
```








-------------------------------------------------------------------------------

-------------------------------------------------------------------------------

Workshop 2: Using ggplot for communication.
Date: 27/08/2024

-------------------------------------------------------------------------------

# Labels
When using plots for communicating your results it is important to have good labels. These labels are a key component in communicating what you want your data to say.

Adding a title to a plot:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se =  FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
```

You can also add more text to this if needed by using other functions:
- subtitle - adds additional detail in smaller font beneath the title
- caption - adds text to the bottom right of the plot and is often used to describe the source of the data.

Add these two functions to the code above:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se =  FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size", 
       subtitle = "Two seaters (sports cars) are an exception because of their light weight", 
       caption = "Data from fueleconomy.gov")
```


Using the labs function we can also replace axis labels and legend titles:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)", 
    y = "Highway fuel economy (mpg)", 
    colour = "Car type"
  )
  

```


# Annotations
Sometimes we want to add text to the plot itself to highlight single observations.

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy))==1) # desc function means descending order

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
```
Some of the labels overlap, there are ways you can handle this issue. This could include using the nudge() function to move your text a certain amount and using other R packages to handle text wrapping etc. 

# Scales
Adjusting your default scales in ggplot2 can also help improve the communication of your results.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```

Creating a plot this way, ggplot2 will automatically add the default scales.
We can change these by giving parameters to the scale arguments.
To provide limits you’ll need to offer a character vector showing the start and end of your limit (e.g. c(0,12).

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(1, 8)) + # Change x axis limts 
  scale_y_continuous(limits = c(10, 45)) + # Change y axis limts 
  scale_colour_discrete()

```
# Axis Ticks
We can also change the ticks on the axes of our plots.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
  
```
Using the code seq(15, 40, by = 5) we tell R to format our y axis limits starting at 15, ending at 40 and to create axis ticks at intervals of 5.

We can use the scale functions to also suppress the labels completely. This would be used for certain formatting purposes.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```


# Legends and Colour schemes










# Replacing a scale






# Themes





# Saving and exporting your plots







#Assignment End-to-end data analysis in R








----------------------------------------------------------------------------------------------------

Workshop 3 - Data Wrangling in R

--------------------------------------------------




---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Talia Murray"
output: html_document
date: "2024-08-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

Workshop 1 -  Data Viz in R
Date: 26/08/2024

-------------------------------------------------------------------------------


# Install and load tidyverse packages.
```{r}
## install.packages("tidyverse") # Delete this line once installed
library("tidyverse")
```


# Load and install the data (palmerpenguins).
```{r}
# install.packages("palmerpenguins")
# install.packages("ggthemes")
library(palmerpenguins)
library(ggthemes)
palmerpenguins::penguins # Source Data set.
penguins<- penguins #Create dataframe. 
```


# Quick data checks.
```{r}
head(penguins) # Shows the top six rows of data set.
glimpse(penguins) # Shows all variables and the first few observations of each variable in the data set.
summary(penguins) # Provides information on each of the variables in the data set.

```
# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?
```{r}
ggplot() 
# Or with just the data specified?
ggplot(data = penguins)
```

If we run ggplot on its own we will just get a blank chart with no axes or information.
using ggplot (data = penguins) R will give us a blank chart again. This is because we have not been specific wth R and told it what we want to plot and how.

# Create first plot.
```{r}
ggplot(data = penguins, 
       mapping = aes(x = flipper_length_mm, y = body_mass_g)) # Mapping argument is defined using the aes() function and the x and y arguments of aes specify the variables we want to map on the x and y axes.
```

Adding the aes code will give us a blank graph with labelled axes showing where flipper length and body mass will be displayed. There is no actual data about the penguins displayed on the chart currently because there is no instructions to R about how to represent the observations from our data onto the plot.

# Add data to first plot.
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g)  # Specify the x and y arguments for the axes.
) +
  geom_point() # Set mapping aesthetics.

```

Now that we have specified the data told R how to represent the data it is now displayed on our chart. From this plot we could begin to answer questions that motivated our analysis for example "What does the relationship between flipper length and body mass look like?". From the chart we have created we can see that there appears to be a positive relationship that indicates that body mass will increase as flipper length increases.

The warning message provided with the chart is telling us that there are two penguins that are missing body mass and/or flipper length in our data set so R has no way of representing them on the plot.

We Want to know if this positive relationship by other variables, for example is it species dependent. To do this we can represent each species on this plot by modifying the aesthetics. 

# Change point colour by species.
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)  # Set arguments for x and y axes.
) +
  geom_point() # Set mapping aesthetics.
```

Using the color feature in aesthetics we can select the species variable from our data set to indicate which point is representing which species. This also creates a figure legend to indicate which color corresponds to which species.

Now we want to add a relationship curve to visualise the relationship between flipper length and body mass for each species.

# Add a relationship curve:
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g, colour = species)  # Set arguments for x and y axes.
) +
  geom_point() + # Set mapping aesthetics
  geom_smooth(method = "lm") # Add a line of best fit.
```

Using the geom_smooth(method = 'lm') tells R we want to draw the line of best fit using a linear model. The warning is relating to the two missing points in our data.

This plot doesn't provide a line of best fit for the entire data set. If we want to correct this to have a line of best fit for the entire data set we need to specify that we only want to separate the points by species.



# Adjust line of best Fit
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g)  # Set arguments for x and y axes.
) +
  geom_point(mapping = aes(colour = species)) + # Use mapping and aesthetics functions to change colour of points for each species.
  geom_smooth(method = "lm") # Add line of best fit.
```

By adding aesthetics to the geom point code we are specifying that we only want to adjust the settings for points on our plot not for every layer on the plot.

To further distinguish the different species we can not only adjust the species point by color but also shape.

# Change point shape by species:
```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g) # Set arguments for x and y axes.
) +
  geom_point(mapping = aes(colour = species, shape = species)) + # Change point color and shape by species type.
  geom_smooth(method = "lm") # Add line of best fit.
```

The points are now changed for each species and this is also represented in the figure legend.

We can further improve our plot aesthetics by improving our axes labels using the labs() function and changing our colour palette.

# Improve aesthetics.
```{r}
ggplot(
  data = penguins, # Specify data set.
  mapping = aes(x = flipper_length_mm, y = body_mass_g) # Set arguments for x and y axes.
) +
  geom_point(aes(colour = species, shape = species)) + # Adjust data point colour and shape.
  geom_smooth(method = "lm") + # Add a line of best fit to entire data set.
  labs(
    title = "Body mass and flipper length", # Label title.
    subtitle = "Dimensions for Adelie, Chinstrap and Gentoo Penguins", # Create a subtitle.
    x = "Flipper length (mm)", y = "Body mass (g)", # Create axes labels.
    color = "Species", shape = "Species" # Adjust legend title.
  ) +
  scale_color_colorblind() # Change color of data points by using a different color palette theme.
```



```{r}
ggplot(
  data = penguins, 
  mapping = aes(x = flipper_length_mm, y = body_mass_g) # Set arguments for x and y axes.
) +
  geom_point(mapping = aes(colour = bill_length_mm)) + # Set bill length as point color.
  geom_smooth() # Add line of best fit.
```


# Faceting

## facet_wrap.
```{r}
ggplot(data = penguins) + # Specify data set.
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + # Specify axes data.
  facet_wrap(~ species, nrow = 2) # This function makes a plot that represents multiple plots which we separated out by species. This now shows three plots for each species. The nrow function tells R how many rows we want on the plot.
```

This shows the relationship flipper length and body mass for each species.

## facet_grid
A separate facet for each combination of sex and species
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  facet_grid( sex ~ species)
```

This shows the relationship flipper length and body mass for each species and then further separates this by sex of the species.


## facet_grid by just row (or column)
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  facet_grid(sex ~ .) # This tells R to just separate data into rows of each sex.
  #facet_grid(. ~ sex) # Alternatively. This will put it as columns.

```

# Exercise:

Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
?facet_wrap

# By default, the same scales are used for all panels. You can allow
# scales to vary across the panels with the `scales` argument.
# Free scales make it easier to see patterns within each panel, but
# harder to compare across panels.
ggplot(penguins, aes(body_mass_g, flipper_length_mm)) +
  geom_point() +
  facet_wrap(vars(species), scales = "free_x")

# ncol dictates the number of columns used. 
# nrow dictates the number of rows used.
# scales adjust the x and y scales. These can be fixed which is the default, or free. When using the free option we can also specify if this is specifically for the x or y axis. In the above example we made the x axis free.
# There are many other options available for the facet_wrap function depending on what your needs are. These are all accessible in the help section.
```

# Using more aesthetics in facet_wraps
```{r}
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(colour = species, shape = species)) +
  facet_wrap(~island)
```



# Lines
We already used points:
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) # Set arguments for x and y axes.
```


However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().

```{r}
ggplot(data = penguins) + 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm))
```

### Question: whey don't we use geom_line() here? What would that look like? ###
The geom line function is not really useful for the purpose of this chart. Using the smooth function we can see the trend or relationship of the data. Using the line aesthetic does not give any useful information regarding the relationship of the data. Instead it is a continuous line of the data moving up and down.


A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didn’t. 

## Using comments (#)
```{r}
ggplot(data = penguins) + 
  #geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) + # Points horrible. 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm)) # Try smooth line.
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.

# Changing linetype
```{r}
ggplot(data = penguins) + 
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm, linetype = species)) # Can also use linetype to specify 
```


# Grouping
```{r}
ggplot(data = penguins) +
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm, group = species))
```
 
# Change line colour based on species value
```{r}
ggplot(data = penguins) +
  geom_smooth(
    mapping = aes(x = body_mass_g, y = flipper_length_mm, color = species),
    show.legend = FALSE,# show.legend = FALSE  tells R not to include the legend on the plot.
  )
```



# Multiple geoms

We already did this one way
```{r}
ggplot(data = penguins) + 
  geom_point(mapping = aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_smooth(mapping = aes(x = body_mass_g, y = flipper_length_mm))
```

A better way...
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point() + 
  geom_smooth()
```


# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point(mapping = aes(color = species)) + 
  geom_smooth()
```



Using the filter option we can specify a species we want to show the line of best fit for.
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point(mapping = aes(color = species)) + 
  geom_smooth(data = filter(penguins, species == "Gentoo"), se = FALSE)
```

#Question: what does the "se = FALSE" do?
se = FALSE does not include the standard error around the line. 

# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.


Run a density plot for the line chart (other times we can just use geom_line but this is not useful for this chart), run a boxplot, histogram and a bar chart.

```{r}
# Density plot:
ggplot(penguins, aes(x = body_mass_g, colour = species)) +
  geom_density(linewidth = 0.75)
#we can map species both to color and fill aesthetics and to make the fill transparent use the alpha aesthetic.
ggplot(penguins, aes(x = body_mass_g, colour = species, fill = species)) +
  geom_density(alpha = 0.5)

# Boxplot:
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()

# Histogram:
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20) # Use the binwidth argument to set the width of the intervals in the histogram, this is measured in the units of the x variable. This size is too narrow for our data.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000) # This binwidth is too large for our data.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200) # This is a better size for our binwidth.


#Bar chart:
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill") # A relative frequency plot is created by setting position = fill in the geom. This is more useful for comparing species distributions across islands since it is not affected by the unequal numbers of penguins across the islands.
```


# Mapping three or more variables
```{r}
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

In this chart we represent the island by shape and the color represents the species.

#3.  Will these two graphs look different? Why/why not?
```{r}
ggplot(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm)) + 
  geom_smooth(data = penguins, mapping = aes(x = body_mass_g, y = flipper_length_mm))
```
No. It says the same thing, the second way is just a longer or more specific way of writing it.

# Transformations and stats
This section will cover transformations and data summaries using the diamond data set that comes with ggplot2. 

## Load data
```{r}
data("diamonds")
glimpse(diamonds)
```

You can use geoms and stats interchangeably which is demonstrated below. The man reason for this is because every geom has a default stat and every stat has a default geom.

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```


# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo
```


```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```

# Question: Why did we specify now specify a y axis?
We need to specify the y axis because stat = "identity" tells R to give a sum of all the values of y. So when we don't specify y R will report an error.

# What if we want to know the proportion rather than the absolute frequency?
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
```

#Question: does R give the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.

Yes.

So, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

```



# Plotting statistical details
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


# Aesthetic adjustments adjustments
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

#Question: Does anyone notice anything different in the colour scheme of this plot?
(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)
Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```


# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```


# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```


# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```


# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```


# position = "dodge" 
Places overlapping objects directly beside one another.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = penguins) + 
  #geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  geom_point(mapping = aes(x = species, y = flipper_length_mm))
```




-------------------------------------------------------------------------------

-------------------------------------------------------------------------------

Workshop 2: Using ggplot for communication.
Date: 27/08/2024

-------------------------------------------------------------------------------

# Labels
When using plots for communicating your results it is important to have good labels. These labels are a key component in communicating what you want your data to say.

Adding a title to a plot:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se =  FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
```

You can also add more text to this if needed by using other functions:
- subtitle - adds additional detail in smaller font beneath the title
- caption - adds text to the bottom right of the plot and is often used to describe the source of the data.

Add these two functions to the code above:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se =  FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size", 
       subtitle = "Two seaters (sports cars) are an exception because of their light weight", 
       caption = "Data from fueleconomy.gov")
```


Using the labs function we can also replace axis labels and legend titles:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)", 
    y = "Highway fuel economy (mpg)", 
    colour = "Car type"
  )
  

```


# Annotations
Sometimes we want to add text to the plot itself to highlight single observations.

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy))==1) # desc function means descending order

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
```
Some of the labels overlap, there are ways you can handle this issue. This could include using the nudge() function to move your text a certain amount and using other R packages to handle text wrapping etc. 

# Scales
Adjusting your default scales in ggplot2 can also help improve the communication of your results.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```

Creating a plot this way, ggplot2 will automatically add the default scales.
We can change these by giving parameters to the scale arguments.
To provide limits you’ll need to offer a character vector showing the start and end of your limit (e.g. c(0,12).

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(limits = c(1, 8)) + # Change x axis limts 
  scale_y_continuous(limits = c(10, 45)) + # Change y axis limts 
  scale_colour_discrete()

```
# Axis Ticks
We can also change the ticks on the axes of our plots.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
  
```
Using the code seq(15, 40, by = 5) we tell R to format our y axis limits starting at 15, ending at 40 and to create axis ticks at intervals of 5.

We can use the scale functions to also suppress the labels completely. This would be used for certain formatting purposes.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```


# Legends and Colour schemes

We can also adjust the location of the legend on our plot using the theme() setting:
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
        geom_point(aes(colour = class))
base + theme(legend.position = "left") # legend.position tells R where we want to position the legend on the plot. This line of code has told R to put the legend on the left.
base + theme(legend.position = "right") # Put legend on the right
base + theme(legend.position = "top") # Put legend on the top of the plot.
base + theme(legend.position = "bottom") # Put legend on the bottom of the plot
base + theme(legend.position = "none") # Tell R to not include a legend.
```



# Replacing a scale

Two types of scales that we might want to swap out are continuous position scales and colour scales. 

It is useful to plot transformations of variables.
Changing the continuous position scale:
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + # Set mapping aesthetic.
  scale_x_log10() + # Log transform x scale.
  scale_y_log10() # Log transform y scale.
```

Function: geom_bin2d divides the plane into rectangles, counts the number of cases and then maps the number of cases to the rectangles fill. This is a useful alternative to geom_point() in the presence of overplotting. You can also adjust the bin sizes.

Changing the colour scale:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = drv)) # Set mapping aesthetic.

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = drv)) +  # Set mapping aesthetic.
  scale_colour_brewer(palette = "Set1") # cChange colour scale. 

```

Scale_colour_brewer provides sequential, diverging and qualitative colour schemes from ColourBrewer. The colour themes are particularly useful for discrete data. Colour Brewer has many different colour schemes available which you can find at: http://colorbrewer2.org/. For more information on colour schemes visit:  http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/ 

if there are only a few colours, adding redundant shape mapping can help ensure your plot is interpretable in black and white.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) + # Set mapping aesthetic and adjust shape of data points.
  scale_colour_brewer(palette = "Set1") # Select colour scale.

```
If you are using predefined colours you are wanting to set yourself use scale_colour_manual().
```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
```
you can also use the viridis colour scheme colour package.
```{r}
# Load and install the required colour packages:

# install.packages('viridis')
# install.packages('hexbin')
library(viridis)
library(viridis)


df <- tibble( # Note: we are just making a fake dataset so we can plot it
  x = rnorm(10000), 
  y = rnorm(10000)
  )
ggplot(df, aes(x, y)) +
  geom_hex() + # Set mapping aesthetic.
  coord_fixed() 

ggplot(df, aes(x, y)) +
  geom_hex() + # Set mapping aesthetic.
  viridis::scale_fill_viridis() + # Select viridis colour package.
  coord_fixed()
```


# Themes

You can also change the entire theme of the plot you build in R.

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()

```


You can also develop your own themes by setting some or all of the arguments to theme() yourself.

For example:
```{r}
 theme (panel.border = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size=8),
        panel.grid.major = element_blank(),
        legend.key = element_blank(),
        legend.background = element_blank(),
        axis.text.y=element_text(colour="black"),
        axis.text.x=element_text(colour="black"),
        text=element_text(family="Arial"))
```


# Saving and exporting your plots

Once you have created a plot, you want to save it in a format that allows you to import it into your report and share it.

You can do this using the ggsave() function. These plots will save to your working directory.

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() # Set mapping aesthetics.

ggsave("my-plot.pdf") # Save plot as a pdf.
```

You can save plots as .jpeg or .pdf though a pdf usually saves nicer.

Sometimes, you might want or need to play with the dimensions of your plot, in which case you can use the width and height arguments to this function.

#Assignment End-to-end data analysis in R








----------------------------------------------------------------------------------------------------

Workshop 3 - Data Wrangling in R

This section will focus on tidying data or data wrangling. This section will demonstrate how to use the tidyr package in the tidyverse to tidy data and the dplyr package for joining data.

--------------------------------------------------


# Import the required libraries.
```{r}
library(tidyverse)
```

We will often need to tidy data to improve the analytical capacity, essentially the way we collect data in the field may not be useful for when we want to analyse it.

To make a data set tidy there are three interrelated rules: 
1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.


Tidy data is useful because:
1. Having a consistent data structure makes it easier to learn the tools that work with it.
2. Having your variables in columns allows R to use its ability to work with vectors of values. This makes transforming tidy data a smoother process.



# 4.4.1 Exercise
1. For each of the sample tables describe what each observation and each column represents
2. Sketch out the processes you would use  to calculate the rate for table 2 and table 3. you will need to perform the four operations:
  a) Extract the number of TB cases per country per year.
  b) Extract the matching population per country per year.
  c) Divide cases by population, and multiply by 10,000.
  d) Store back in the appropriate place.
  

# Pivoting data to make it tidy
There are two common problems with untidy data:
1. One variable is spread across multiple columns
2. One observation is scattered across multiple rows.

To fix these we will pivot our data into tidy form using two functions in tidyr: pivot_longer() to lengthen data and pivot_wider() to widen data.

# Lengthening datasets
For this exercise we will use the billboard dataset.
```{r}
# Load billboard dataset
billboard
# In this dataset each observation is a song, the first three columns, artist track and date.entered are variables to describe the song. then we have 76 columns (wk1 - wk76) that describes the rank of the song in each week.
# Here the column names are one variable (the week) and the cell values are another (the rank)
# to tidy the data we will use the pivot_longer() function.

# Lengthen data
billboard |>
  pivot_longer(
    cols =  starts_with("wk"),
    names_to = "Week", 
    values_to = "Rank"
  )
```

There are  three key arguments in the pivot_longer() function:
  1. cols which specifies the columns you want to pivot.
  2. names_to which names th variables stored in the column names. We chose to name the variable week.
  3. values_to which names the variable stored in the cell values that we named rank.
  
  
There are now NAs in the data that we created when we changed the structure of the dataset, not because the values are unknown. Therefore we can remove these by adding the argument values_drop_na = TRUE
```{r}
# Lengthen data and remove NAs
billboard |>
  pivot_longer(
    cols =  starts_with("wk"),
    names_to = "Week", 
    values_to = "Rank", 
    values_drop_na = TRUE
  )
```
The data is now tidy but we could also do more to improve the format to make future computation easier, for example, we could convert some of our values from strings to numbers using mutate() and parse_number().


# Pivoting longer
```{r}
# Create a small data set using tribble called "df" with 3 variables and their associated values.
df <- tribble(
  ~id, ~bp1, ~bp2, 
  "A", 100, 120, 
  "B", 140, 115, 
  "C", 120, 125
)

# Tidy data by making it longer:
df |> # |> is a piping function.
  pivot_longer(
    cols = bp1:bp2, 
    names_to = "Measurement", 
    values_to = "Value"
  )
# Now we can see how the data changed and was lengthened.
```

# Widening Datasets
In less common cases, we may need to widen a dataset. Widening is essentially the opposite of lengthening and we do so by using the function pivot_wider().

We will use an example from R4DS to explore pivot_wider() looking at the cms_patient_experience dataset from the centers of Medicare and Medicaid.

```{r}
# Load data.
cms_patient_experience
```
The core unit being studied is an organisation but in the current format each organisation is spread across 6 rows with one row for each measurement taken in the survey organisation.
We can see the complete set of values for measure_cd and measure_title by using distinct()
```{r}
cms_patient_experience |>
  distinct(measure_cd, measure_title)
```

Neither of these will make great variable names - measure_cd doesn't hint at the meaning of the variable and measure_title is a long sentence with spaces. So, we will use measure_cd as the source for our new column names  for now, but in a real analysis you might want to create your own variable names that are both short and meaningful.

pivot_wider() has the opposite interface to pivot_longer(): instead of choosing new column names, we need to provide the existing columns that define the vlaues (values_from) and the column name (names_from):
```{r}
cms_patient_experience |>
  pivot_wider(
    names_from = measure_cd, 
    values_from = prf_rate
  )
```
The above output doesn't look quite right, we still have multiple rows for each organisation. That is because we also need to tell pivot_wider() which column or columns have values that uniquely identify each row; in this case those are the variables starting with "org".
```{r}
cms_patient_experience |>
  pivot_wider(
    id_cols = starts_with("org"), 
    names_from = measure_cd, 
    values_from = prf_rate
  )
```
Create a smaller example pivot_wider using tribble.
```{r}
# Create dataset.
df <- tribble(
   ~id, ~Measurement, ~Value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)

# Widen dataset by taking the names from the measurement column using the names_from() argument and the values from the value column using the values_from() argument.
df |> 
  pivot_wider(
    names_from = Measurement,
    values_from = Value
  )

# To start the pivoting process, pivot_wider() needs to first figure out what will go in the rows and columns. The new column names will be the unique values of measurement.
df |> 
  distinct(Measurement) |> 
  pull()

# The rows in the output are determined by all the variables that aren’t going into the new names or values. These are called the id_cols. Here there is only one column, but in general there can be any number.
df |> 
  select(-Measurement, -Value) |> 
  distinct()

# Pivot wider then combines these results to generate an empty dataframe:
df |> 
  select(-Measurement, -Value) |> 
  distinct() |> 
  mutate(x = NA, y = NA, z = NA)
# It then fills in all the missing values using the data in the input. IN this case, not every cell in the output has a corresponding value in the input as there is no third blood pressure measurement for patient B, so that cell remains missing.
```

# 4.5.5 Exercises
Why are pivot_longer() and pivot_wider() not perfectly symmetrical? Carefully consider the following example. 
```{r}

```

Why does this code fail?

Consider the sample tibble below. Do you need to make it wider or longer? What are the variables?


# Separating and uniting data tables
# Separating
This section will cover separating one column into multiple.
```{r}
# Load data.
table3

# We need to split the rate column into two variables: 1) Cases, 2) Population.
# separate() will take the name of the column we want to split and the names of the columns we want it to split into.
table3 %>%
  separate(rate, into = c("cases", "population"))

```
By default R will split values wherever it sees a non-alphanumeric character. For example, in the code above, separate() split the values of rate at the forward slash characters. If you wish to use a specific character to separate a column, you can pass the character to the sep argument of separate(). For example, we could rewrite the code above as:
```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), sep = "/")
```
Notice the data types in table3 above. Both cases and population are listed as character (<chr>) types. This is a default of using separate(). However, since the values in those columns are actually numbers, we want to ask separate() to convert them to better types using convert = TRUE.
```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), convert = TRUE)
```

We can also pass a vector of integers to sep. separate() will interpret the integers as positions to split at. Positive values start at 1 on the far-left of the strings; negative values start at -1 on the far-right of the strings. When using integers to separate strings, the length of sep should be one less than the number of names in into.
We can use this arrangement to separate the last two digits of each year


```{r}
table3 %>%
  separate(year, into = c("century", "year"), sep = 2) # Separate year by the location of the second number.
```
 
# Uniting 

The inverse of separating is uniting which uses the unite() function. This combines multiple columns into a single column.
Use table 5 for this exercise and rejoin the century and year columns.
```{r}
# Join year and century columns using unite().
table5 %>%
  unite(new, century, year, sep = "") # Use sep = "" because we don't want any separator in the new variable.
```
# Handling missing values
Missing values are sometimes shown with NA or sometimes they could be simply missing altogether from the data (a blank cell).
# Explicit missing values
The way data is missing matters a lot when tidying your data. When you see NA this is an example of explicit absence, and a blank cell also inidcates the absence of data but this is known as implicit absence.

A common example for missing values is as a data entry convenience. When data is entered by hand, missing values sometimes indicate that the value in the previous row has been repeated (or carried forward, for example:
```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

We can fill in these missing values with tidyr::fill() which works in a similar way to select(), taking a set of columns:
```{r}
treatment |>
  fill(everything())
```
This is also called "last observation carried forward" of locf. You can use the .direction argument to fill in missing values that have been generated in a more complicated way.

# fixed values
```{r}
# Sometimes missing values represent some fixed and known value, most commonly 0. You can use dplyr::coalesce() to replace them.
x <- c (1, 4, 5, 7, NA)
coalesce(x, 0) # This will change the NA value in x to 0.

# Sometimes you’ll encounter the opposite problem where some other concrete value actually represents a missing value.
x <- c(1, 4, 5, 7, -99)
na_if(x, -99)

# This typically happens when data is generated from an older software that can’t properly represent missing values so it uses something like 99 or -999 in place of the missing value. You can fix this with dplyr::na_if():

```
# NaN
One special type of missing value worth mentioning is NaN or Not a Number. It typically behaves the same as NA but in some rare cases you may need to distinguish it using is.nan(x):
```{r}
x <- c(NA, NaN)
x * 10
x == 1
is.na(x)
```
NaN is common when performing a mathematical operation that has an indeterminate result.


# Implicit missing values
Demonstrate a dataset with implicit absence. 
```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)

```
This dataset has two missing observations:
1) The price in the fourth quarter of 2020 is explicitly missing, because its value is NA.
2) The price for the first quarter of 2021 is implicitly missing, because it simply does not appear in the dataset.

Sometimes we want to make the implicit missing values explicit. In other situations explicit missing values are forced upon you by the structure of the data and you want to get rid of those.

A good example of this can be shown using the stocks data:
```{r}
stocks |>
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )
```
The function tidyr::complete() allows you to generate explicit missing values by providing a set of variables that define the combination of rows that should exist.

```{r}
# For Exampele: all combinations of year and qtr should exist in the stocks data:
stocks |>
  complete(year, qtr)
# Normally, we call complete() with names of existing variables to fill in the missing cimbinations. Sometimes the individual variables are incomplete. So instead, we can provide our own data. 
# For example, we might know that the stocks dataset is supposed to run from 2019 to 2021, so you could explicitly supply those values for year:
stocks |>
  complete(year = 2019:2021, qtr)
```



# Importing into R
# CSV files 
Most common file type for tabular data is a .csv
Important things to consider when using .csv fies :
  1) The first row or “header row” gives the column names.
  2) The following six rows provide the data.
  3) Columns are separated by commas.
  
  
To import a csv file into R we use the readr package and use the  read_csv() function.
```{r}
? read_csv # Go to help to lear more about read_csv function
# students <- read_csv("C://data/students.csv") # Put pathway to required csv file in the "" so R can find the csv file. Comment this out for now because this line won't actually work as the file doesn't exist on your system.

# To access this csv to use for the following examples read the csv into R using the URL.
students <- read_csv("https://pos.it/r4ds-students-csv")
```
Need to check that our observations are in rows and that our variables are in columns.
So, after we input a csv file we should check the data to make sure it is set up correctly and to ensure there are no errors.
```{r}
# Look at data.
students
```
We can see there are some N/A values in the favourite.food variable. The issue here is R has treated the missing value as a character string (actual value) rather than as a real NA. We can fix this using a simple code when we read in our csv:
```{r}
students <- read_csv("https://pos.it/r4ds-students-csv", na = c("N/A", ""))
students
```

Sometimes the variable names may have backticks surrounding them. We can fix this by doing a code like this:
```{r}
students |> 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )
```


# 4.7.3 Exercises
Identify what is wrong with each of the following inline CSV files. What happens when you run the code?


# Learning relational data


```{r}
# Load data and install required packages
# install.packages("nycflights13") # Comment out once installed.

library(nycflights13)

airlines # Look at data.
airports # Look at data.
planes # Look at data.
weather # Look at data.
```


# Joining datasets
We join datasets together by identifying keys. A key is a variable (or set of variables) that uniquely identifies an observation. For example, each plane is uniquely identified by its tailnum. In other cases, multiple variables may be needed. For example, to identify an observation in weather you need five variables: year, month, day, hour, origin.

There are two kinds of keys, these are primary and foreign. 
A primary key uniquely identifies an observation in its own table. For example, planes$tailnum is a primary key because it uniquely identifies each plane in the planes table.
A foreign key uniquely identifies an observation in another table. For example, flights$tailnum is a foreign key because it appears in the flights table where it matches each flight to a unique plane.
```{r}
# After identifying the primary keys in our tables, we need to verify if they do uniquely identify each observation. We can do this using count():
planes %>%
  count(tailnum) %>%
  filter(n > 1)
  
weather %>%
  count(year, month, day, hour, origin) %>%
  filter(n > 1)

# Sometimes a table doesn’t have an explicit primary key: each row is an observation, but no combination of variables reliably identifies it. For example, you might expect that the primary key for flights would be the date plus the flight or tail number, but neither of those are unique:

flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)

flights %>%
  count(year, month, day, tailnum) %>%
  filter(n > 1)
```


# Mutating Joins

```{r}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)

```



```{r}
flights2 %>%
  select(-origin, -dest) %>% 
  left_join(airlines, by = "carrier")

```



```{r}
flights2 %>%
  select(-origin, -dest) %>% 
  mutate(name = airlines$name[match(carrier, airlines$carrier)])
```

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```






```{r}
x %>% 
  inner_join(y, by = "key")
```




```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
left_join(x, y, by = "key")
```



```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)
left_join(x, y, by = "key")
```

```{r}
flights2 %>% 
  left_join(weather)
```

```{r}
flights2 %>% 
  left_join(planes, by = "tailnum")
```

```{r}
flights2 %>% 
  left_join(airports, c("dest" = "faa"))
```

```{r}
flights2 %>% 
  left_join(airports, c("origin" = "faa"))
```



# Pipes for more readable workflows
```{r}
foo_foo <- little_bunny
```



```{r}
foo_foo_1 <- hop(foo_foo, through = forest)
foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
foo_foo_3 <- bop(foo_foo_2, on = head)
```



```{r}
foo_foo <- hop(foo_foo, through = forest)
foo_foo <- scoop(foo_foo, up = field_mice)
foo_foo <- bop(foo_foo, on = head)
```



```{r}
bop(
  scoop(
    hop(foo_foo, through = forest),
    up = field_mice
  ), 
  on = head
)
```



```{r}
foo_foo %>%
  hop(through = forest) %>%
  scoop(up = field_mice) %>%
  bop(on = head)
```











-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
Workshop 4 - Spatial data in R

This section will demonstrate how to use GIS in R.
-------------------------------------------------------------------------------

# Install and load required packages
```{r}
# install.packages("sf") # Comment out after install.
# install.packages("terra") # Comment out after install.
# install.packages("tmap") # Comment out after install.

# Load into R library.
library(tidyverse)
library(sf) # Simple features.
library(terra) # For raster.
library(tmap) # Thematic maps are geographical maps in which spatial data distributions are visualised.

```

# Downloading and loading the spatial dataset

```{r}
# Load the copepod data into R
library(readr)
dat <- read_csv("../data/data-for-course/copepods_raw.csv")
dat
```
# Data Exploration
# Check coordinates
```{r}
library(ggplot2)
ggplot(dat) +
  aes(x = longitude, y = latitude, colour = richness_raw) +
  geom_point()
```

```{r}
ggplot(dat, aes(x = latitude, y = richness_raw)) +
  stat_smooth() +
  geom_point()
```


# Getting going with maps
```{r}
sdat <- st_as_sf(dat, coords = c("longitude", "latitude"), crs = 4326)
```


```{r}
crs4326 <- st_crs(4326)
crs4326 # Look at whole crs.
crs4326$Name # Pull out just the name of the crs.
```
Now check what the WKT looks like
```{r}
crs4326$wkt # crs in well-known text format.
```




# Feature collection (points)
```{r}
sdat
```


# Cartography
```{r}
plot(sdat["richness_raw"])
```

```{r}
plot(sdat)
```



# Thematic maps for communication
```{r}
# Using tmap
tm_shape(sdat) +
  tm_dots(col = "richness_raw")
```


```{r}
tmap_save(tm, filename = "Richness-map.png",
          width = 600, height = 600)
```

# Mapping spatial polygons as layers
# Loading shapefiles
```{r}
aus <- st_read("../data/data-for-course/spatial-data/Aussie/Aussie.shp") # Read in shapefile.

aus # Look at data.

shelf <- st_read("../data/data-for-course/spatial-data/aus_shelf/aus_shelf.shp") # read in shapefile

shelf # Look at data.
```

# Mapping your polygons
```{r}
tm_shape(shelf) +
  tm_polygons()
```

```{r}
tm_shape(shelf, bbox = sdat) +
  tm_polygons() +
  tm_shape(aus) +
  tm_polygons() +
  tm_shape(sdat) +
  tm_dots()
```


# Exploring t_map
```{r}
vignette('tmap-getstarted')

# Hello World!
library(tmap)
data("World")
tm_shape(World) +
  tm_polygons("HPI")
```


```{r}
# Interactive Maps
tmap_mode("view")

tm_shape(World) + 
  tm_polygons("HPI")
```


```{r}
# Multiple shapes and layers
data(World, metro, rivers, land)

tmap_mode("plot") #tmap mode set to plotting
tm_shape(land) +
  tm_raster("elevation", palette = terrain.colors(10)) +
  tm_shape(World) +
  tm_borders("white", lwd = .5) +
  tm_text("iso_a3", size = "AREA") +
  tm_shape(metro) +
  tm_symbols(col = "red", size = "pop2020", scale = .5) +
  tm_legend(show = FALSE)
```


```{r}
# Facets
# Facets can be created in three ways:

# 1) By assigning multiple variable names to one aesthetic ( in this example the first argument of tm_polygons:
tmap_mode("view")
tm_shape(World) +
  tm_polygons(c("HPI", "economy")) +
  tm_facets(sync = TRUE, ncol = 2)

# 2) By splitting the spatial data with the by argument of tm_facets:
tmap_mode("plot") # tmap mode set to plotting

data("NLD_muni")
NLD_muni$perc_men <- NLD_muni$pop_men / NLD_muni$population * 100
tm_shape(NLD_muni) +
  tm_polygons("perc_men", palette = "RdYlBu") +
  tm_facets(by = "province")

# 3) By using the tmap_arrange function
tmap_mode("plot") # tmap mode set to plotting.

data("NLD_muni")
tm1 <- tm_shape(NLD_muni) + tm_polygons("population", convert2density = TRUE)
tm2 <- tm_shape(NLD_muni) + tm_bubbles(size = "population")

tmap_arrange(tm1, tm2)
```


```{r}
# Basemaps and overlay tile maps
tmap_mode("view")
tm_basemap("Stamen.Watercolor ") +
  tm_shape(metro) + tm_bubbles(size = "pop2020", col = "red") +
  tm_tiles("Stamen.TonerLabels")
```


```{r}
# Options and styles 
tmap_mode("plot") # tmap mode set to plotting

tm_shape(World) +
  tm_polygons("HPI") +
  tm_layout(bg.color = "skyblue", inner.margins = c(0, .02, .02, .02))



tmap_options(bg.color = "black", legend.text.color ="white")

tm_shape(World) +
  tm_polygons("HPI", legend.title = "Happy Planet Index")

tmap_style("classic")

tm_shape(World) +
  tm_polygons("HPI", legend.title = "Happy Planet Index")

# See what options have been changed. 
tmap_options_diff()

# Reset the options to the default values.
tmap_options_reset()
```

```{r}
# Exporting Maps
tm <- tm_shape(World) +
  tm_polygons("HPI", legend.title = "Happy Planet Index")

# Save an image ("plot" mode).
tmap_save(tm, filename = "world_map.png")

# Save as stand-alone HTML file ("view" mode).
tmap_save(tm, filename = "world_map.html")

```

```{r}
# Shiny integration

# In UI part:
tmapOutput("my_tmap")

# In server part:
output$my_tmap = renderTmap({
  tm_shape(World) + tm_polygons("HPI", legend.title = "Happy Planet Index")
})
```


```{r}
# Quick thematic map
qtm(World, fill = "HPI", fill.palette = "RdYlGn")
```
```{r}
# Tips and Tricks
# Run:
tmap_tip()
```





